# 230409: Build Web App with Shiny

Fabian Aiolfi
Please help me build a Shiny web app with R.

The final web app has a dropdown with every parliamentarian from the column “PersonNumber” in the dataframe “member_council_legislative_period_51”.

When the user selects a person from the dropdown, the web app displays the selected parliamentarian’s vote history as a list of items of business. The dataframe “voting_legislative_period_51” contains every parliamentarian’s vote history. The column “PersonNumber” links this dataframe to “member_council_legislative_period_51”. The column “DecisionText” shows how the parliamentarian voted. The column “BusinessShortNumber” shows which item of business was voted on.

The web app displays a three point summary for each item of business. The summaries are provided by the dataframe “sample_business” and its three columns “Point_1”, “Point_2”, and “Point_3”.

The web app groups the voting history by “DecisionText”.

ChatGPT
To build this Shiny web app, follow these steps:

Install and load the required packages.
R
Copy code
install.packages("shiny")
install.packages("dplyr")

library(shiny)
library(dplyr)
Create a ui object with a dropdown input and an output for the voting history.
R
Copy code
ui <- fluidPage(
  titlePanel("Parliamentarian Voting History"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput(
        "selected_person",
        "Choose a parliamentarian:",
        choices = unique(member_council_legislative_period_51$PersonNumber),
        selected = NULL
      )
    ),
    
    mainPanel(
      uiOutput("vote_history")
    )
  )
)
Create a server function that takes input from the dropdown and displays the voting history.
R
Copy code
server <- function(input, output) {
  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      person_vote_history <- voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        left_join(sample_business, by = "BusinessShortNumber") %>%
        group_by(DecisionText) %>%
        arrange(BusinessShortNumber)
      
      output_list <- list()
      
      for (group in unique(person_vote_history$DecisionText)) {
        output_list[[group]] <- renderDataTable({
          votes <- person_vote_history %>%
            filter(DecisionText == group) %>%
            select(BusinessShortNumber, Point_1, Point_2, Point_3, DecisionText)
          
          datatable(votes)
        })
      }
      
      return(output_list)
    } else {
      return(NULL)
    }
  })
}
Create the Shiny app using the ui and server objects.
R
Copy code
shinyApp(ui = ui, server = server)
This code will create a Shiny web app with a dropdown menu for selecting a parliamentarian. After selecting a parliamentarian, the app will display their voting history as a list of items of business with a three-point summary for each item. The voting history will be grouped by the "DecisionText" column.




Fabian Aiolfi
Looking good. But the web app doesn't display the vote history. Instead it shows "Error: could not find function "datatable"". Any suggestions?

ChatGPT
Apologies for the oversight. It looks like we forgot to load the DT package, which provides the datatable() function. Follow these steps to fix the issue:

Install and load the DT package:
R
Copy code
install.packages("DT")

library(DT)
Update the server function to use DTOutput and renderDT instead of renderDataTable. This will ensure compatibility with the DT package:
R
Copy code
server <- function(input, output) {
  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      person_vote_history <- voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        left_join(sample_business, by = "BusinessShortNumber") %>%
        group_by(DecisionText) %>%
        arrange(BusinessShortNumber)
      
      output_list <- list()
      
      for (group in unique(person_vote_history$DecisionText)) {
        output_list[[group]] <- DTOutput(group)
        output[[group]] <- renderDT({
          votes <- person_vote_history %>%
            filter(DecisionText == group) %>%
            select(BusinessShortNumber, Point_1, Point_2, Point_3, DecisionText)
          
          datatable(votes)
        })
      }
      
      return(output_list)
    } else {
      return(NULL)
    }
  })
}
With these changes, the web app should now display the vote history without any errors.




Fabian Aiolfi
Great, no errors!
I would like to make a change. Please only display the items of business that are in the "sample_business" dataframe. Their unique IDs are provided by the column "BusinessShortNumber".

ChatGPT
To display only the items of business that are in the "sample_business" dataframe, you can add an additional filter to the person_vote_history pipeline. Update the server function as follows:

R
Copy code
server <- function(input, output) {
  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      person_vote_history <- voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        inner_join(sample_business, by = "BusinessShortNumber") %>%
        group_by(DecisionText) %>%
        arrange(BusinessShortNumber)
      
      output_list <- list()
      
      for (group in unique(person_vote_history$DecisionText)) {
        output_list[[group]] <- DTOutput(group)
        output[[group]] <- renderDT({
          votes <- person_vote_history %>%
            filter(DecisionText == group) %>%
            select(BusinessShortNumber, Point_1, Point_2, Point_3, DecisionText)
          
          datatable(votes)
        })
      }
      
      return(output_list)
    } else {
      return(NULL)
    }
  })
}
The only change is using inner_join(sample_business, by = "BusinessShortNumber") instead of left_join(sample_business, by = "BusinessShortNumber"). The inner_join() function will only include rows from both dataframes that have a matching "BusinessShortNumber". This will ensure that only items of business in the "sample_business" dataframe are displayed.




Fabian Aiolfi
This works, excellent.
The web app sometimes displays some items of business twice and sometimes shows two duplicate tables. Every items of business should only appear once and there should only be one table.

ChatGPT
To ensure that each item of business appears only once and there's only one table, you can remove the loop that iterates through the unique values of "DecisionText". Instead, you can simply create a single table with all the voting history.

Here's the updated server function:

R
Copy code
server <- function(input, output) {
  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      person_vote_history <- voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        inner_join(sample_business, by = "BusinessShortNumber") %>%
        group_by(DecisionText) %>%
        arrange(BusinessShortNumber) %>%
        ungroup()

      DTOutput("vote_history_table")
    } else {
      return(NULL)
    }
  })

  output$vote_history_table <- renderDT({
    if (!is.null(input$selected_person)) {
      datatable(person_vote_history)
    }
  })
}
This version of the server function creates a single output named "vote_history_table" and populates it with the person_vote_history datatable. The loop that iterated through the unique values of "DecisionText" has been removed, ensuring only one table is displayed.

With these changes, the web app should display a single table with each item of business appearing only once.




Fabian Aiolfi
This gives me the error: "object 'person_vote_history' not found".

ChatGPT
Apologies for the oversight. You'll need to use a reactive expression to store the person_vote_history so that it can be accessed in multiple places within the server function. Here's the corrected version of the server function:

R
Copy code
server <- function(input, output) {
  person_vote_history <- reactive({
    if (!is.null(input$selected_person)) {
      voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        inner_join(sample_business, by = "BusinessShortNumber") %>%
        group_by(DecisionText) %>%
        arrange(BusinessShortNumber) %>%
        ungroup()
    } else {
      return(NULL)
    }
  })

  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      DTOutput("vote_history_table")
    } else {
      return(NULL)
    }
  })

  output$vote_history_table <- renderDT({
    if (!is.null(input$selected_person)) {
      datatable(person_vote_history())
    }
  })
}
Now the person_vote_history is defined as a reactive expression using reactive({...}). This allows you to access the updated value of person_vote_history by calling it as a function, like person_vote_history(), in both the renderUI and renderDT functions.

With these changes, the error should be resolved, and the web app should display a single table with each item of business appearing only once.




Fabian Aiolfi
No errors, but the displayed output is wrong. It now shows all items of business from the dataframe "business_legislative_period_51" and all its columns. I only want the items of business from the "sample_business" dataframe, and only the columns BusinessShortNumber, Point_1, Point_2, Point_3 and DecisionText.

ChatGPT
I apologize for the confusion. I misunderstood your requirements. Here's the corrected version of the server function that only displays the items of business from the "sample_business" dataframe and includes only the columns "BusinessShortNumber", "Point_1", "Point_2", "Point_3", and "DecisionText":

R
Copy code
server <- function(input, output) {
  person_vote_history <- reactive({
    if (!is.null(input$selected_person)) {
      voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        inner_join(sample_business, by = "BusinessShortNumber") %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        select(BusinessShortNumber, Point_1, Point_2, Point_3, DecisionText) %>%
        arrange(BusinessShortNumber)
    } else {
      return(NULL)
    }
  })

  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      DTOutput("vote_history_table")
    } else {
      return(NULL)
    }
  })

  output$vote_history_table <- renderDT({
    if (!is.null(input$selected_person)) {
      datatable(person_vote_history())
    }
  })
}
In this version of the server function, I've changed the order of the joins and placed the select() function after the joins, specifying only the columns you want to display. This should give you the correct output with only the desired columns from the "sample_business" dataframe.

With these changes, the web app should display a single table with each item of business appearing only once, showing only the specified columns.




Fabian Aiolfi
Thanks, this is working very well.
Please make the following change: An item of business should only ever appear once in a parliamentarian's vote history. In other words: Prevent duplicate items of business in the table.

ChatGPT
To prevent duplicate items of business in the table, you can use the distinct() function from the dplyr package to remove duplicates based on the "BusinessShortNumber" column. Update the server function as follows:

R
Copy code
server <- function(input, output) {
  person_vote_history <- reactive({
    if (!is.null(input$selected_person)) {
      voting_legislative_period_51 %>%
        filter(PersonNumber == input$selected_person) %>%
        inner_join(sample_business, by = "BusinessShortNumber") %>%
        left_join(member_council_legislative_period_51, by = "PersonNumber") %>%
        select(BusinessShortNumber, Point_1, Point_2, Point_3, DecisionText) %>%
        distinct(BusinessShortNumber, .keep_all = TRUE) %>%
        arrange(BusinessShortNumber)
    } else {
      return(NULL)
    }
  })

  output$vote_history <- renderUI({
    if (!is.null(input$selected_person)) {
      DTOutput("vote_history_table")
    } else {
      return(NULL)
    }
  })

  output$vote_history_table <- renderDT({
    if (!is.null(input$selected_person)) {
      datatable(person_vote_history())
    }
  })
}
The only change is the addition of the distinct(BusinessShortNumber, .keep_all = TRUE) function after the select() function. This will remove duplicate rows based on the "BusinessShortNumber" column while keeping all other column data for the first occurrence of each unique item of business.

With this change, the web app should display a single table with each item of business appearing only once, without any duplicates.




Fabian Aiolfi
Excellent, this is exactly what I wanted. Thanks!


# 230412: Build Web App with Shiny to display and help evaluate ChatGPT output

Please help me build a Shiny web app in R.
The user can select a “BusinessShortNumber” in a dropdown. This is provided by the column “BusinessShortNumber” in the dataframe “sample_business”.
Once the user has picked a “BusinessShortNumber”, the text from the column “InitialSituation” is displayed.
Below that text we see the corresponding text from the “content” column in the dataframe “chatgpt_output_df”. The dataframes “sample_business” and “chatgpt_output_df” both have the column “BusinessShortNumber”. The content from “chatgpt_output_df” is sorted by “query_type”.
Directly above each block of content is displayed the string from the object which has the same name as the “query_type”.

To create a Shiny web app in R that meets your requirements, follow the steps below. I assume you have R and RStudio installed, as well as the necessary packages (shiny and dplyr). If not, you can install the required packages using install.packages(c("shiny", "dplyr")).

Create a new R script, and save it as app.R in a new directory.
In app.R, load the required libraries and prepare the sample data:
R
Copy code
library(shiny)
library(dplyr)

# Sample data
sample_business <- data.frame(
  BusinessShortNumber = c("A001", "A002", "A003"),
  InitialSituation = c("Initial situation 1", "Initial situation 2", "Initial situation 3")
)

chatgpt_output_df <- data.frame(
  BusinessShortNumber = c("A001", "A001", "A002", "A002", "A003", "A003"),
  content = c("Content 1A", "Content 1B", "Content 2A", "Content 2B", "Content 3A", "Content 3B"),
  query_type = c("TypeA", "TypeB", "TypeA", "TypeB", "TypeA", "TypeB")
)

# Query type strings
TypeA <- "Type A Header"
TypeB <- "Type B Header"
Define the UI and server components of your Shiny app:
R
Copy code
ui <- fluidPage(
  titlePanel("Business Short Number App"),
  sidebarLayout(
    sidebarPanel(
      selectInput("business_short_number", "Select BusinessShortNumber:",
                  choices = sample_business$BusinessShortNumber)
    ),
    mainPanel(
      h3("Initial Situation:"),
      textOutput("initial_situation_text"),
      br(),
      h3("Corresponding Content:"),
      uiOutput("chatgpt_content")
    )
  )
)

server <- function(input, output) {
  output$initial_situation_text <- renderText({
    req(input$business_short_number)
    sample_business[sample_business$BusinessShortNumber == input$business_short_number, "InitialSituation"]
  })

  output$chatgpt_content <- renderUI({
    req(input$business_short_number)
    chatgpt_content_filtered <- chatgpt_output_df %>%
      filter(BusinessShortNumber == input$business_short_number) %>%
      arrange(query_type)
    
    content_blocks <- lapply(unique(chatgpt_content_filtered$query_type), function(query_type) {
      content_header <- textOutput(paste0("header_", query_type))
      content_text <- textOutput(paste0("content_", query_type))
      
      output[[paste0("header_", query_type)]] <- renderText(get(query_type))
      output[[paste0("content_", query_type)]] <- renderText(paste(chatgpt_content_filtered[chatgpt_content_filtered$query_type == query_type, "content"], collapse = "\n"))
      
      list(content_header, br(), content_text, br())
    })
    
    do.call(tagList, content_blocks)
  })
}

shinyApp(ui = ui, server = server)
Save the app.R file and run the Shiny app by executing runApp("Path/to/your/app_directory") in the R console or clicking on the "Run App" button in RStudio. The app will display the Initial Situation text based on the selected BusinessShortNumber, as well as the corresponding content, sorted by query type, with the header string for each query type.



Fabian Aiolfi
Looking good. However, below "Initial Situation:" there's an error:
argument 1 (type 'list') cannot be handled by 'cat'
Apologies for the oversight. It seems that the issue arises because the textOutput doesn't handle lists as expected. Instead, you can use verbatimTextOutput and modify the code as follows:

Replace this line:

R
Copy code
textOutput("initial_situation_text"),
with:

R
Copy code
verbatimTextOutput("initial_situation_text"),
Then, your Shiny app should display the initial situation text without any errors.




Fabian Aiolfi
No, still getting the same error at the same place:
argument 1 (type 'list') cannot be handled by 'cat'
I apologize for the confusion. I misunderstood the source of the error earlier. The error is actually caused by renderText returning a list instead of a character vector. This can be fixed by using as.character to convert the output to a character vector. Please update the renderText block in the server function as follows:

Replace this code block:

R
Copy code
output$initial_situation_text <- renderText({
    req(input$business_short_number)
    sample_business[sample_business$BusinessShortNumber == input$business_short_number, "InitialSituation"]
})
with:

R
Copy code
output$initial_situation_text <- renderText({
    req(input$business_short_number)
    as.character(sample_business[sample_business$BusinessShortNumber == input$business_short_number, "InitialSituation"])
})
Now your Shiny app should display the initial situation text without any errors.




Fabian Aiolfi
How can I make the "query_type" string above the blocks of content bold?
To make the "query_type" string above the blocks of content bold, you can wrap the text output in an HTML <strong> tag using the tags$strong() function. Modify the content_header line in the lapply function like this:

Replace this line:

R
Copy code
content_header <- textOutput(paste0("header_", query_type))
with:

R
Copy code
content_header <- tags$strong(textOutput(paste0("header_", query_type)))
This will make the "query_type" string above each block of content bold.




Fabian Aiolfi
The text in "initial_situation_text" contains HTML tags. Is there a way to render them as HTML?
Yes, you can render the text as HTML by using renderUI and HTML() functions instead of renderText. Replace the textOutput in the UI and the renderText in the server function with the following code:

Replace this line in the ui section:

R
Copy code
verbatimTextOutput("initial_situation_text"),
with:

R
Copy code
uiOutput("initial_situation_text"),
And replace this code block in the server function:

R
Copy code
output$initial_situation_text <- renderText({
    req(input$business_short_number)
    as.character(sample_business[sample_business$BusinessShortNumber == input$business_short_number, "InitialSituation"])
})
with:

R
Copy code
output$initial_situation_text <- renderUI({
    req(input$business_short_number)
    initial_situation_html <- as.character(sample_business[sample_business$BusinessShortNumber == input$business_short_number, "InitialSituation"])
    HTML(initial_situation_html)
})
Now, the "initial_situation_text" output will render any HTML tags in the text correctly.


-------------------------------------------------

# 230419: Build Web App with Shiny

Fabian Aiolfi
Please help me build a Shiny web app with R.

The final web app has a dropdown with every parliamentarian from the column “PersonNumber” in the dataframe “member_council_legislative_period_51”.

When the user selects a parliamentarian from the dropdown, the web app displays the selected parliamentarian’s vote history as a list of items of business. The dataframe “voting_legislative_period_51” contains every parliamentarian’s vote history. The column “PersonNumber” links this dataframe to “member_council_legislative_period_51”. The column “DecisionText” shows how the parliamentarian voted. The column “BusinessShortNumber” shows which item of business was voted on.

Each item of business is displayed in the following manner:
- Title of the item of business, provided by the column “Title” in the dataframe  “business_legislative_period_51”
- Summary of the items of business, provided by the column “query_central_stmnt”  in the dataframe “chatgpt_output_df”
- Category values, provided by columns number 3 through number 10 in the dataframe “chatgpt_output_df”